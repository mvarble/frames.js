"use strict";function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj}}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj}}return _typeof(obj)}Object.defineProperty(exports,"__esModule",{value:true});exports.multiplyMatrixStack=multiplyMatrixStack;exports.withWorldMatrix=withWorldMatrix;exports.normalizedFrame=normalizedFrame;exports.transformedByMatrix=transformedByMatrix;exports.withRatio=exports.scaledFrame=exports.rotatedFrame=exports.translatedFrame=exports.vecsFrameTrans=exports.vecFrameTrans=exports.locsFrameTrans=exports.locFrameTrans=exports.frameToFrameMatrix=exports.withChild=exports.prepArrays=exports.prepArray=exports.prepVecs=exports.prepVec=exports.prepLocs=exports.prepLoc=void 0;var math=_interopRequireWildcard(require("mathjs"));var _cloneDeep=_interopRequireDefault(require("lodash/cloneDeep"));var _unistUtilVisit=_interopRequireDefault(require("unist-util-visit"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}function _getRequireWildcardCache(){if(typeof WeakMap!=="function")return null;var cache=new WeakMap;_getRequireWildcardCache=function _getRequireWildcardCache(){return cache};return cache}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}if(obj===null||_typeof(obj)!=="object"&&typeof obj!=="function"){return{"default":obj}}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj["default"]=obj;if(cache){cache.set(obj,newObj)}return newObj}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)==="[object Arguments]")return Array.from(iter)}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++){arr2[i]=arr[i]}return arr2}}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}// start building the module default export
var out={};// simply allows a giant product
function multiplyMatrixStack(array){if(!array.length){return math.identity(3)}else if(array.length==1){return array[0]}else if(array.length==2){return math.multiply(array[1],array[0])}else{return math.multiply(array.slice(-1)[0],multiplyMatrixStack(array.slice(0,-1)))}}out=_objectSpread({},out,{multiplyMatrixStack:multiplyMatrixStack});// these will prep mathjs <-> js objects accordingly
var prepLoc=function prepLoc(array){return math.transpose(math.matrix([[].concat(_toConsumableArray(array),[1])]))};exports.prepLoc=prepLoc;var prepLocs=function prepLocs(array){return math.transpose(math.matrix(array.map(function(a){return[].concat(_toConsumableArray(a),[1])})))};exports.prepLocs=prepLocs;var prepVec=function prepVec(array){return math.transpose(math.matrix([[].concat(_toConsumableArray(array),[0])]))};exports.prepVec=prepVec;var prepVecs=function prepVecs(array){return math.transpose(math.matrix(array.map(function(a){return[].concat(_toConsumableArray(a),[0])})))};exports.prepVecs=prepVecs;var prepArray=function prepArray(matrix){return math.transpose(matrix).valueOf()[0].slice(0,-1)};exports.prepArray=prepArray;var prepArrays=function prepArrays(matrix){return math.transpose(matrix).valueOf().map(function(a){return a.slice(0,-1)})};exports.prepArrays=prepArrays;out=_objectSpread({},out,{prepLoc:prepLoc,prepLocs:prepLocs,prepVec:prepVec,prepVecs:prepVecs,prepArray:prepArray,prepArrays:prepArrays});// this will simply append a child to the front of an array
var withChild=function withChild(frame,child){return _objectSpread({},frame,{children:[child].concat(_toConsumableArray(frame.children))})};exports.withChild=withChild;out=_objectSpread({},out,{withChild:withChild});// this will generate the matrix which transfers between frames
var frameToFrameMatrix=function frameToFrameMatrix(frame1,frame2){return math.multiply(math.inv(frame2.worldMatrix),frame1.worldMatrix)};exports.frameToFrameMatrix=frameToFrameMatrix;out=_objectSpread({},out,{frameToFrameMatrix:frameToFrameMatrix});// these will convert `frame1` location coordinates to those of `frame2`
var locFrameTrans=function locFrameTrans(coords,frame1,frame2){return prepArray(math.multiply(frameToFrameMatrix(frame1,frame2),prepLoc(coords)))};exports.locFrameTrans=locFrameTrans;var locsFrameTrans=function locsFrameTrans(coordsArray,frame1,frame2){return prepArrays(math.multiply(frameToFrameMatrix(frame1,frame2),prepLocs(coordsArray)))};exports.locsFrameTrans=locsFrameTrans;out=_objectSpread({},out,{locFrameTrans:locFrameTrans,locsFrameTrans:locsFrameTrans});// these will convert `frame1` vector coordinates to those of `frame2`
var vecFrameTrans=function vecFrameTrans(coords,frame1,frame2){return prepArray(math.multiply(frameToFrameMatrix(frame1,frame2),prepVec(coords)))};exports.vecFrameTrans=vecFrameTrans;var vecsFrameTrans=function vecsFrameTrans(coordsArray,frame1,frame2){return prepArrays(math.multiply(frameToFrameMatrix(frame1,frame2),prepVecs(coordsArray)))};exports.vecsFrameTrans=vecsFrameTrans;out=_objectSpread({},out,{vecFrameTrans:vecFrameTrans,vecsFrameTrans:vecsFrameTrans});// this will output a frame in which the inputted one was transformed to get the
// new matrix (children affected)
function withWorldMatrix(frame,matrix){var newFrame=(0,_cloneDeep["default"])(frame);var oldMatrix=newFrame.worldMatrix;(0,_unistUtilVisit["default"])(newFrame,function(node,index,parent){if(parent&&node.worldMatrix){parent.children[index].worldMatrix=multiplyMatrixStack([node.worldMatrix,math.inv(oldMatrix),matrix])}});newFrame.worldMatrix=matrix;return newFrame}out=_objectSpread({},out,{withWorldMatrix:withWorldMatrix});// this will return a copy of the inputted frame, transformed so that its basis
// is normalized
function normalizedFrame(frame){var array=frame.worldMatrix.valueOf();var basis=[[array[0][0],array[1][0]],[array[0][1],array[1][1]]];var nBasis=basis.map(function(x){return math.multiply(x,1/math.norm(x))});var matrix=math.matrix([[].concat(_toConsumableArray(nBasis[0]),[array[0][2]]),[].concat(_toConsumableArray(nBasis[1]),[array[1][2]]),[0,0,1]]);return withWorldMatrix(frame,matrix)}out=_objectSpread({},out,{normalizedFrame:normalizedFrame});// this will enact a transformation of a frame `frame` via the matrix `matrix`, 
// relative to `relFrame`.
function transformedByMatrix(frame,matrix,relFrame){if(relFrame){return withWorldMatrix(frame,multiplyMatrixStack([frame.worldMatrix,math.inv(relFrame.worldMatrix),matrix,relFrame.worldMatrix]))}else{return withWorldMatrix(frame,multiplyMatrixStack([matrix,frame.worldMatrix]))}}out=_objectSpread({},out,{transformedByMatrix:transformedByMatrix});// this is a wrapper by `transformedByMatrix` in which the transformation is
// a translation
var translatedFrame=function translatedFrame(frame,vecCoord,relFrame){return transformedByMatrix(frame,math.matrix([[1,0,vecCoord[0]],[0,1,vecCoord[1]],[0,0,1]]),relFrame)};exports.translatedFrame=translatedFrame;out=_objectSpread({},out,{translatedFrame:translatedFrame});// this is a wrapper by `transformedByMatrix` in which the transformation is
// a rotation
var rotatedFrame=function rotatedFrame(frame,theta,relFrame){return transformedByMatrix(frame,math.matrix([[math.cos(theta),-math.sin(theta),0],[math.sin(theta),math.cos(theta),0],[0,0,1]]),relFrame)};exports.rotatedFrame=rotatedFrame;out=_objectSpread({},out,{rotatedFrame:rotatedFrame});// this is a wrapper by `transformedByMatrix` in which the transformation is
// a scale
var scaledFrame=function scaledFrame(frame,scales,relFrame){return transformedByMatrix(frame,math.matrix([[scales[0],0,0],[0,scales[1],0],[0,0,1]]),relFrame)};exports.scaledFrame=scaledFrame;out=_objectSpread({},out,{scaledFrame:scaledFrame});// this simply returns the determinant of the basis vectors in the frame
var frameDet=function frameDet(frame){var M=frame.worldMatrix.valueOf();return M[0][0]*M[1][1]-M[1][0]*M[0][1]};out=_objectSpread({},out,{frameDet:frameDet});// this returns a transformed version of the frame, in which the basis vectors
// will be scaled to have an inputted ratio (determinant fixed)
var withRatio=function withRatio(frame,ratio){var sqrtJac=math.sqrt(math.abs(frameDet(frame)));return scaledFrame(normalizedFrame(frame),[sqrtJac*ratio,sqrtJac])};exports.withRatio=withRatio;out=_objectSpread({},out,{withRatio:withRatio});//export default out;